{% extends "base.html" %}

{% block styles %}
<style>
    .container {
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
    }
    
    h1 {
        text-align: center;
        margin-bottom: 30px;
    }
    
    /* Difficulty selector */
    .difficulty-selector {
        display: flex;
        justify-content: center;
        margin-bottom: 20px;
        gap: 10px;
    }
    
    /* Player info section */
    .player-panel {
        display: flex;
        justify-content: space-between;
        margin-bottom: 20px;
    }
    
    .player {
        padding: 10px 15px;
        border-radius: 8px;
        display: flex;
        align-items: center;
        transition: all 0.3s;
    }
    
    .player.active {
        transform: scale(1.05);
        box-shadow: 0 0 10px rgba(0,0,0,0.2);
    }
    
    .player-1 {
        background-color: rgba(255, 0, 0, 0.1);
    }
    
    .player-2 {
        background-color: rgba(255, 255, 0, 0.1);
    }
    
    .player-disc {
        width: 25px;
        height: 25px;
        border-radius: 50%;
        margin-right: 10px;
    }
    
    .player-1 .player-disc {
        background-color: #ff0000;
    }
    
    .player-2 .player-disc {
        background-color: #ffff00;
    }
    
    .turn-indicator {
        text-align: center;
        font-weight: bold;
        padding: 10px;
        background-color: #f8f9fa;
        border-radius: 8px;
        margin-bottom: 20px;
    }
    
    /* Game board */
    .game-board {
        background-color: #0055aa;
        padding: 15px;
        border-radius: 10px;
        display: inline-block;
        margin: 0 auto;
        box-shadow: 0 0 20px rgba(0,0,0,0.3);
    }
    
    .board-container {
        display: flex;
        justify-content: center;
        margin-bottom: 20px;
    }
    
    /* Column buttons */
    .column-buttons {
        display: flex;
        margin-bottom: 10px;
    }
    
    .column-button {
        width: 50px;
        height: 30px;
        margin: 0 5px;
        background-color: #dddddd;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.3s;
    }
    
    .column-button:hover {
        background-color: #bbbbbb;
    }
    
    /* Game cells */
    .board-row {
        display: flex;
    }
    
    .board-cell {
        width: 50px;
        height: 50px;
        background-color: #ffffff;
        border-radius: 50%;
        margin: 5px;
        box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
    }
    
    .red-disc {
        background-color: #ff0000;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        animation: drop-disc 0.5s;
    }
    
    .yellow-disc {
        background-color: #ffff00;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        animation: drop-disc 0.5s;
    }
    
    @keyframes drop-disc {
        0% { transform: translateY(-300%); }
        100% { transform: translateY(0); }
    }
    
    /* Game actions */
    .game-actions {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 20px;
    }
    
    /* AI thinking animation */
    .thinking-indicator {
        display: inline-block;
        vertical-align: middle;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(0, 0, 0, 0.3);
        border-radius: 50%;
        border-top-color: #000;
        animation: spin 1s linear infinite;
        margin-left: 10px;
    }
    
    @keyframes spin {
        to { transform: rotate(360deg); }
    }
    
    /* Responsive adjustments */
    @media (max-width: 600px) {
        .board-cell {
            width: 40px;
            height: 40px;
            margin: 3px;
        }
        
        .column-button {
            width: 40px;
            margin: 0 3px;
        }
    }
    
    /* Win/draw message */
    #game-result {
        text-align: center;
        font-weight: bold;
        padding: 10px;
        margin-top: 20px;
        border-radius: 8px;
        display: none;
    }
    
    .win-message {
        background-color: #d4edda;
        color: #155724;
    }
    
    .draw-message {
        background-color: #f8d7da;
        color: #721c24;
    }
    
    /* AI thinking */
    .ai-thinking {
        display: inline-block;
        position: relative;
    }
    
    .ai-thinking:after {
        content: ' .';
        animation: thinking 1.5s steps(4, end) infinite;
    }
    
    @keyframes thinking {
        0%, 20% { content: ' '; }
        40% { content: ' .'; }
        60% { content: ' ..'; }
        80% { content: ' ...'; }
    }
    
    /* Stats display */
    .ai-stats {
        margin-top: 10px;
        font-size: 0.9em;
        color: #666;
        text-align: center;
        height: 20px;
    }
</style>
{% endblock %}

{% block content %}
<div class="container">
    <h1>Connect Four - AI Game</h1>
    
    <div class="difficulty-selector">
        <button class="btn btn-outline-primary difficulty-btn" data-difficulty="easy">Easy</button>
        <button class="btn btn-primary difficulty-btn" data-difficulty="medium">Medium</button>
        <button class="btn btn-outline-danger difficulty-btn" data-difficulty="hard">Hard</button>
    </div>
    
    <div class="player-panel">
        <div class="player player-1 active" id="player1">
            <div class="player-disc"></div>
            <span>You</span>
        </div>
        
        <div class="turn-indicator" id="turn-indicator">
            Your Turn
        </div>
        
        <div class="player player-2" id="player2">
            <div class="player-disc"></div>
            <span>AI</span>
        </div>
    </div>
    
    <div class="board-container">
        <div class="game-board">
            <div class="column-buttons" id="column-buttons">
                <button class="column-button" data-col="0">↓</button>
                <button class="column-button" data-col="1">↓</button>
                <button class="column-button" data-col="2">↓</button>
                <button class="column-button" data-col="3">↓</button>
                <button class="column-button" data-col="4">↓</button>
                <button class="column-button" data-col="5">↓</button>
                <button class="column-button" data-col="6">↓</button>
            </div>
            
            <div id="board">
                <!-- Row 0 (top row) -->
                <div class="board-row">
                    <div class="board-cell" data-row="0" data-col="0"></div>
                    <div class="board-cell" data-row="0" data-col="1"></div>
                    <div class="board-cell" data-row="0" data-col="2"></div>
                    <div class="board-cell" data-row="0" data-col="3"></div>
                    <div class="board-cell" data-row="0" data-col="4"></div>
                    <div class="board-cell" data-row="0" data-col="5"></div>
                    <div class="board-cell" data-row="0" data-col="6"></div>
                </div>
                
                <!-- Row 1 -->
                <div class="board-row">
                    <div class="board-cell" data-row="1" data-col="0"></div>
                    <div class="board-cell" data-row="1" data-col="1"></div>
                    <div class="board-cell" data-row="1" data-col="2"></div>
                    <div class="board-cell" data-row="1" data-col="3"></div>
                    <div class="board-cell" data-row="1" data-col="4"></div>
                    <div class="board-cell" data-row="1" data-col="5"></div>
                    <div class="board-cell" data-row="1" data-col="6"></div>
                </div>
                
                <!-- Row 2 -->
                <div class="board-row">
                    <div class="board-cell" data-row="2" data-col="0"></div>
                    <div class="board-cell" data-row="2" data-col="1"></div>
                    <div class="board-cell" data-row="2" data-col="2"></div>
                    <div class="board-cell" data-row="2" data-col="3"></div>
                    <div class="board-cell" data-row="2" data-col="4"></div>
                    <div class="board-cell" data-row="2" data-col="5"></div>
                    <div class="board-cell" data-row="2" data-col="6"></div>
                </div>
                
                <!-- Row 3 -->
                <div class="board-row">
                    <div class="board-cell" data-row="3" data-col="0"></div>
                    <div class="board-cell" data-row="3" data-col="1"></div>
                    <div class="board-cell" data-row="3" data-col="2"></div>
                    <div class="board-cell" data-row="3" data-col="3"></div>
                    <div class="board-cell" data-row="3" data-col="4"></div>
                    <div class="board-cell" data-row="3" data-col="5"></div>
                    <div class="board-cell" data-row="3" data-col="6"></div>
                </div>
                
                <!-- Row 4 -->
                <div class="board-row">
                    <div class="board-cell" data-row="4" data-col="0"></div>
                    <div class="board-cell" data-row="4" data-col="1"></div>
                    <div class="board-cell" data-row="4" data-col="2"></div>
                    <div class="board-cell" data-row="4" data-col="3"></div>
                    <div class="board-cell" data-row="4" data-col="4"></div>
                    <div class="board-cell" data-row="4" data-col="5"></div>
                    <div class="board-cell" data-row="4" data-col="6"></div>
                </div>
                
                <!-- Row 5 (bottom row) -->
                <div class="board-row">
                    <div class="board-cell" data-row="5" data-col="0"></div>
                    <div class="board-cell" data-row="5" data-col="1"></div>
                    <div class="board-cell" data-row="5" data-col="2"></div>
                    <div class="board-cell" data-row="5" data-col="3"></div>
                    <div class="board-cell" data-row="5" data-col="4"></div>
                    <div class="board-cell" data-row="5" data-col="5"></div>
                    <div class="board-cell" data-row="5" data-col="6"></div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="game-result"></div>
    <div id="ai-stats" class="ai-stats"></div>
    
    <div class="game-actions">
        <button id="new-game" class="btn btn-warning">New Game</button>
        <button id="undo-move" class="btn btn-secondary">Undo Move</button>
        <a href="{{ url_for('connect_four_home') }}" class="btn btn-outline-primary">Back to Menu</a>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Game constants
        const ROWS = 6;
        const COLS = 7;
        const EMPTY = 0;
        const PLAYER = 1;
        const AI = 2;
        
        // Game state
        let currentPlayer = PLAYER;
        let gameActive = true;
        let board = Array(ROWS).fill().map(() => Array(COLS).fill(EMPTY));
        let moveHistory = [];
        let aiDifficulty = 'medium';
        let aiIsThinking = false;
        let positionsEvaluated = 0;
        
        // DOM Elements
        const columnButtons = document.querySelectorAll('.column-button');
        const difficultyButtons = document.querySelectorAll('.difficulty-btn');
        const playerElement = document.getElementById('player1');
        const aiElement = document.getElementById('player2');
        const turnIndicator = document.getElementById('turn-indicator');
        const gameResultElement = document.getElementById('game-result');
        const newGameButton = document.getElementById('new-game');
        const undoMoveButton = document.getElementById('undo-move');
        const aiStatsElement = document.getElementById('ai-stats');
        
        // Initialize the game
        function initGame() {
            // Reset game state
            currentPlayer = PLAYER;
            gameActive = true;
            board = Array(ROWS).fill().map(() => Array(COLS).fill(EMPTY));
            moveHistory = [];
            
            // Clear the board UI
            const cells = document.querySelectorAll('.board-cell');
            cells.forEach(cell => {
                cell.innerHTML = '';
            });
            
            // Update UI
            updateTurnIndicator();
            updatePlayerHighlight();
            
            // Hide any game result message
            gameResultElement.style.display = 'none';
            aiStatsElement.textContent = '';
        }
        
        // Make a move in the specified column
        function makeMove(col, isAI = false) {
            if (!gameActive || aiIsThinking) return;
            if (!isAI && currentPlayer !== PLAYER) return;
            if (isAI && currentPlayer !== AI) return;
            
            // Find the lowest empty row in the column
            const row = findLowestEmptyRow(col);
            if (row === -1) return; // Column is full
            
            // Update the board array
            board[row][col] = currentPlayer;
            moveHistory.push({ row, col, player: currentPlayer });
            
            // Update the UI
            updateCellUI(row, col);
            
            // Check for win or draw
            if (checkWin(row, col, board)) {
                gameActive = false;
                const winner = currentPlayer === PLAYER ? 'You win!' : 'AI wins!';
                showGameResult(winner, true);
                return;
            }
            
            if (checkDraw(board)) {
                gameActive = false;
                showGameResult("It's a draw!", false);
                return;
            }
            
            // Switch players
            currentPlayer = currentPlayer === PLAYER ? AI : PLAYER;
            updateTurnIndicator();
            updatePlayerHighlight();
            
            // If it's AI's turn, make AI move
            if (currentPlayer === AI && gameActive) {
                aiIsThinking = true;
                turnIndicator.innerHTML = 'AI Thinking<span class="thinking-indicator"></span>';
                
                // Reset position counter
                positionsEvaluated = 0;
                aiStatsElement.textContent = "Analyzing...";
                
                // Use setTimeout to allow UI to update and show the thinking indicator
                setTimeout(() => {
                    const startTime = performance.now();
                    const aiCol = getAIMove();
                    const endTime = performance.now();
                    const timeSpent = Math.round(endTime - startTime);
                    
                    aiStatsElement.textContent = `AI analyzed ${positionsEvaluated.toLocaleString()} positions in ${timeSpent}ms`;
                    
                    // Add a slight delay to make the move seem more natural
                    setTimeout(() => {
                        aiIsThinking = false;
                        makeMove(aiCol, true);
                    }, 500);
                }, 100);
            }
        }
        
        // Find the lowest empty row in a column
        function findLowestEmptyRow(col) {
            for (let row = ROWS - 1; row >= 0; row--) {
                if (board[row][col] === EMPTY) {
                    return row;
                }
            }
            return -1; // Column is full
        }
        
        // Update the UI of a cell
        function updateCellUI(row, col) {
            const cell = document.querySelector(`.board-cell[data-row="${row}"][data-col="${col}"]`);
            const disc = document.createElement('div');
            disc.className = currentPlayer === PLAYER ? 'red-disc' : 'yellow-disc';
            cell.appendChild(disc);
        }
        
        // Update the turn indicator
        function updateTurnIndicator() {
            if (currentPlayer === PLAYER) {
                turnIndicator.textContent = 'Your Turn';
            } else {
                turnIndicator.textContent = 'AI Thinking...';
            }
        }
        
        // Update player highlight
        function updatePlayerHighlight() {
            if (currentPlayer === PLAYER) {
                playerElement.classList.add('active');
                aiElement.classList.remove('active');
            } else {
                playerElement.classList.remove('active');
                aiElement.classList.add('active');
            }
        }
        
        // Show game result message
        function showGameResult(message, isWin) {
            gameResultElement.textContent = message;
            gameResultElement.className = isWin ? 'win-message' : 'draw-message';
            gameResultElement.style.display = 'block';
        }
        
        // Check if the last move resulted in a win
        function checkWin(row, col, checkBoard) {
            const player = checkBoard[row][col];
            if (player === EMPTY) return false;
            
            const directions = [
                [0, 1],  // horizontal
                [1, 0],  // vertical
                [1, 1],  // diagonal down-right
                [1, -1]  // diagonal down-left
            ];
            
            for (const [dx, dy] of directions) {
                let count = 1;  // Start with 1 for the piece just placed
                
                // Check in the positive direction
                for (let i = 1; i < 4; i++) {
                    const r = row + i * dx;
                    const c = col + i * dy;
                    
                    if (r >= 0 && r < ROWS && c >= 0 && c < COLS && checkBoard[r][c] === player) {
                        count++;
                    } else {
                        break;
                    }
                }
                
                // Check in the negative direction
                for (let i = 1; i < 4; i++) {
                    const r = row - i * dx;
                    const c = col - i * dy;
                    
                    if (r >= 0 && r < ROWS && c >= 0 && c < COLS && checkBoard[r][c] === player) {
                        count++;
                    } else {
                        break;
                    }
                }
                
                if (count >= 4) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Check if the game is a draw
        function checkDraw(checkBoard) {
            // Game is a draw if all top row cells are filled
            return checkBoard[0].every(cell => cell !== EMPTY);
        }
        
        // Undo the last move
        function undoMove() {
            if (moveHistory.length === 0 || aiIsThinking) return;
            
            // If it's the player's turn, we need to undo two moves (AI and player)
            // If it's the AI's turn, we only need to undo one move (player)
            const movesToUndo = currentPlayer === PLAYER ? 2 : 1;
            
            for (let i = 0; i < movesToUndo && moveHistory.length > 0; i++) {
                const lastMove = moveHistory.pop();
                board[lastMove.row][lastMove.col] = EMPTY;
                
                // Update UI
                const cell = document.querySelector(`.board-cell[data-row="${lastMove.row}"][data-col="${lastMove.col}"]`);
                cell.innerHTML = '';
            }
            
            // Restore game state if it was over
            if (!gameActive) {
                gameActive = true;
                gameResultElement.style.display = 'none';
                aiStatsElement.textContent = '';
            }
            
            // Always set to player's turn after undo
            currentPlayer = PLAYER;
            updateTurnIndicator();
            updatePlayerHighlight();
        }
        
        // Get AI move
        function getAIMove() {
            switch (aiDifficulty) {
                case 'easy':
                    return getEasyAIMove();
                case 'medium':
                    return getMediumAIMove();
                case 'hard':
                    return getHardAIMove();
                default:
                    return getMediumAIMove();
            }
        }
        
        // Easy AI: Makes very basic moves with some randomness
        function getEasyAIMove() {
            // Update the AI stats
            positionsEvaluated = Math.floor(Math.random() * 10) + 5; // Fake a small number
            
            // 60% chance of just playing randomly
            if (Math.random() < 0.6) {
                // Make a fully random move
                const validColumns = [];
                for (let col = 0; col < COLS; col++) {
                    if (findLowestEmptyRow(col) !== -1) {
                        validColumns.push(col);
                    }
                }
                return validColumns[Math.floor(Math.random() * validColumns.length)];
            }
            
            // 40% chance of making a slightly smarter move
            
            // Check for AI win in one move (always take an immediate win)
            for (let col = 0; col < COLS; col++) {
                const row = findLowestEmptyRow(col);
                if (row === -1) continue;
                
                // Try the move
                board[row][col] = AI;
                const isWin = checkWin(row, col, board);
                // Undo the move
                board[row][col] = EMPTY;
                
                if (isWin) {
                    return col; // Winning move found
                }
            }
            
            // Only 50% chance of blocking opponent's win
            if (Math.random() < 0.5) {
                for (let col = 0; col < COLS; col++) {
                    const row = findLowestEmptyRow(col);
                    if (row === -1) continue;
                    
                    // Try the move as player
                    board[row][col] = PLAYER;
                    const isWin = checkWin(row, col, board);
                    // Undo the move
                    board[row][col] = EMPTY;
                    
                    if (isWin) {
                        return col; // Blocking move found
                    }
                }
            }
            
            // 30% chance of preferring the center (if not doing the above)
            if (Math.random() < 0.3) {
                const centerCol = 3;
                if (findLowestEmptyRow(centerCol) !== -1) {
                    return centerCol;
                }
            }
            
            // Otherwise just pick a random column
            const validColumns = [];
            for (let col = 0; col < COLS; col++) {
                if (findLowestEmptyRow(col) !== -1) {
                    validColumns.push(col);
                }
            }
            
            return validColumns[Math.floor(Math.random() * validColumns.length)];
        }
        
        // Medium AI: Makes strategically sound moves but doesn't look too far ahead
        function getMediumAIMove() {
            // Update stats - pretend to analyze a moderate number of positions
            positionsEvaluated = Math.floor(Math.random() * 100) + 50;
            
            // First check if AI can win in the next move (always take immediate wins)
            for (let col = 0; col < COLS; col++) {
                const row = findLowestEmptyRow(col);
                if (row === -1) continue;
                
                // Try the move
                board[row][col] = AI;
                const isWin = checkWin(row, col, board);
                // Undo the move
                board[row][col] = EMPTY;
                
                if (isWin) {
                    return col; // Winning move found
                }
            }
            
            // Always block player's immediate wins
            for (let col = 0; col < COLS; col++) {
                const row = findLowestEmptyRow(col);
                if (row === -1) continue;
                
                // Try the move as player
                board[row][col] = PLAYER;
                const isWin = checkWin(row, col, board);
                // Undo the move
                board[row][col] = EMPTY;
                
                if (isWin) {
                    return col; // Blocking move found
                }
            }
            
            // Look for the best move using a simplified evaluation (no deep lookahead)
            let bestScore = -1000;
            let bestCol = -1;
            
            // For each valid move, evaluate the resulting position
            for (let col = 0; col < COLS; col++) {
                const row = findLowestEmptyRow(col);
                if (row === -1) continue;
                
                // Make the move
                board[row][col] = AI;
                
                // Evaluate the position
                const score = evaluateBoard(board);
                
                // Undo the move
                board[row][col] = EMPTY;
                
                // Update best move if this is better
                if (score > bestScore) {
                    bestScore = score;
                    bestCol = col;
                } else if (score === bestScore && Math.random() < 0.5) {
                    // Add some randomness for equal scores
                    bestCol = col;
                }
            }
            
            // If we found a good move, use it
            if (bestCol !== -1) {
                return bestCol;
            }
            
            // Fallback to center preference strategy
            const colPriority = [3, 2, 4, 1, 5, 0, 6]; // Center first, then radiating outwards
            for (const col of colPriority) {
                if (findLowestEmptyRow(col) !== -1) {
                    return col;
                }
            }
            
            // Ultimate fallback (should rarely reach this)
            const validColumns = [];
            for (let col = 0; col < COLS; col++) {
                if (findLowestEmptyRow(col) !== -1) {
                    validColumns.push(col);
                }
            }
            return validColumns[Math.floor(Math.random() * validColumns.length)];
        }
        
        // Hard AI: Uses Minimax with alpha-beta pruning for advanced lookahead
        function getHardAIMove() {
            // Use minimax with alpha-beta pruning to find the best move
            const depth = 6; // Look ahead 6 moves (more challenging)
            let bestScore = -Infinity;
            let bestCol = -1;
            
            // Start with checking the center column - often the best strategic choice
            const centerCol = 3;
            const centerRow = findLowestEmptyRow(centerCol);
            if (centerRow !== -1) {
                // Try the center move first
                board[centerRow][centerCol] = AI;
                
                // Evaluate move using minimax
                const centerScore = minimax(board, depth - 1, -Infinity, Infinity, false);
                
                // Undo the move
                board[centerRow][centerCol] = EMPTY;
                
                // Set initial best move to center
                bestScore = centerScore;
                bestCol = centerCol;
            }
            
            // For each other possible move
            for (let col = 0; col < COLS; col++) {
                // Skip center column as we already evaluated it
                if (col === centerCol) continue;
                
                const row = findLowestEmptyRow(col);
                if (row === -1) continue; // Skip full columns
                
                // Make the move
                board[row][col] = AI;
                
                // Evaluate move using minimax
                const score = minimax(board, depth - 1, -Infinity, Infinity, false);
                
                // Undo the move
                board[row][col] = EMPTY;
                
                // Update best move
                if (score > bestScore) {
                    bestScore = score;
                    bestCol = col;
                }
            }
            
            // Return the best column found
            return bestCol;
        }
        
        // Minimax algorithm with alpha-beta pruning
        function minimax(boardState, depth, alpha, beta, isMaximizing) {
            positionsEvaluated++;
            
            // Check for terminal state
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (boardState[r][c] !== EMPTY) {
                        if (checkWin(r, c, boardState)) {
                            return boardState[r][c] === AI ? 1000 + depth : -1000 - depth;
                        }
                    }
                }
            }
            
            if (depth === 0 || checkDraw(boardState)) {
                return evaluateBoard(boardState);
            }
            
            if (isMaximizing) {
                // AI's turn (maximizing)
                let maxEval = -Infinity;
                
                for (let col = 0; col < COLS; col++) {
                    const row = findLowestEmptyRow(col);
                    if (row === -1) continue;
                    
                    // Make the move
                    boardState[row][col] = AI;
                    
                    // Evaluate this position recursively
                    const evalScore = minimax(boardState, depth - 1, alpha, beta, false);
                    
                    // Undo the move
                    boardState[row][col] = EMPTY;
                    
                    maxEval = Math.max(maxEval, evalScore);
                    alpha = Math.max(alpha, evalScore);
                    
                    // Alpha-beta pruning
                    if (beta <= alpha) break;
                }
                
                return maxEval;
            } else {
                // Player's turn (minimizing)
                let minEval = Infinity;
                
                for (let col = 0; col < COLS; col++) {
                    const row = findLowestEmptyRow(col);
                    if (row === -1) continue;
                    
                    // Make the move
                    boardState[row][col] = PLAYER;
                    
                    // Evaluate this position recursively
                    const evalScore = minimax(boardState, depth - 1, alpha, beta, true);
                    
                    // Undo the move
                    boardState[row][col] = EMPTY;
                    
                    minEval = Math.min(minEval, evalScore);
                    beta = Math.min(beta, evalScore);
                    
                    // Alpha-beta pruning
                    if (beta <= alpha) break;
                }
                
                return minEval;
            }
        }
        
        // Evaluate current board position
        function evaluateBoard(boardState) {
            let score = 0;
            
            // Evaluate horizontal windows
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c <= COLS - 4; c++) {
                    score += evaluateWindow(
                        [boardState[r][c], boardState[r][c+1], 
                         boardState[r][c+2], boardState[r][c+3]]
                    );
                }
            }
            
            // Evaluate vertical windows
            for (let r = 0; r <= ROWS - 4; r++) {
                for (let c = 0; c < COLS; c++) {
                    score += evaluateWindow(
                        [boardState[r][c], boardState[r+1][c], 
                         boardState[r+2][c], boardState[r+3][c]]
                    );
                }
            }
            
            // Evaluate diagonal windows (positive slope)
            for (let r = 3; r < ROWS; r++) {
                for (let c = 0; c <= COLS - 4; c++) {
                    score += evaluateWindow(
                        [boardState[r][c], boardState[r-1][c+1], 
                         boardState[r-2][c+2], boardState[r-3][c+3]]
                    );
                }
            }
            
            // Evaluate diagonal windows (negative slope)
            for (let r = 0; r <= ROWS - 4; r++) {
                for (let c = 0; c <= COLS - 4; c++) {
                    score += evaluateWindow(
                        [boardState[r][c], boardState[r+1][c+1], 
                         boardState[r+2][c+2], boardState[r+3][c+3]]
                    );
                }
            }
            
            // Prefer center column
            for (let r = 0; r < ROWS; r++) {
                if (boardState[r][3] === AI) {
                    score += 3;
                }
            }
            
            return score;
        }
        
        // Evaluate a window of 4 pieces
        function evaluateWindow(window) {
            const aiCount = window.filter(cell => cell === AI).length;
            const playerCount = window.filter(cell => cell === PLAYER).length;
            const emptyCount = window.filter(cell => cell === EMPTY).length;
            
            // AI win possibilities
            if (aiCount === 4) return 100;
            if (aiCount === 3 && emptyCount === 1) return 5;
            if (aiCount === 2 && emptyCount === 2) return 2;
            
            // Block player win possibilities
            if (playerCount === 3 && emptyCount === 1) return -4;
            
            return 0;
        }
        
        // Evaluate position for potential threats
        function evaluatePosition(boardState, player, count) {
            let score = 0;
            
            // Check for consecutive pieces with open ends
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (boardState[r][c] === player) {
                        // Check horizontal
                        if (c <= COLS - count) {
                            let consecutive = true;
                            for (let i = 0; i < count; i++) {
                                if (boardState[r][c+i] !== player) {
                                    consecutive = false;
                                    break;
                                }
                            }
                            
                            if (consecutive) {
                                // Check if open on either end
                                let openEnds = 0;
                                if (c > 0 && boardState[r][c-1] === EMPTY) openEnds++;
                                if (c+count < COLS && boardState[r][c+count] === EMPTY) openEnds++;
                                
                                score += openEnds * count;
                            }
                        }
                        
                        // Check vertical
                        if (r <= ROWS - count) {
                            let consecutive = true;
                            for (let i = 0; i < count; i++) {
                                if (boardState[r+i][c] !== player) {
                                    consecutive = false;
                                    break;
                                }
                            }
                            
                            if (consecutive) {
                                // For vertical, only the top can be open
                                if (r+count < ROWS && boardState[r+count][c] === EMPTY) {
                                    score += count;
                                }
                            }
                        }
                        
                        // Check diagonal (down-right)
                        if (r <= ROWS - count && c <= COLS - count) {
                            let consecutive = true;
                            for (let i = 0; i < count; i++) {
                                if (boardState[r+i][c+i] !== player) {
                                    consecutive = false;
                                    break;
                                }
                            }
                            
                            if (consecutive) {
                                // Check if open on either end
                                let openEnds = 0;
                                if (r > 0 && c > 0 && boardState[r-1][c-1] === EMPTY) openEnds++;
                                if (r+count < ROWS && c+count < COLS && boardState[r+count][c+count] === EMPTY) openEnds++;
                                
                                score += openEnds * count;
                            }
                        }
                        
                        // Check diagonal (down-left)
                        if (r <= ROWS - count && c >= count - 1) {
                            let consecutive = true;
                            for (let i = 0; i < count; i++) {
                                if (boardState[r+i][c-i] !== player) {
                                    consecutive = false;
                                    break;
                                }
                            }
                            
                            if (consecutive) {
                                // Check if open on either end
                                let openEnds = 0;
                                if (r > 0 && c < COLS - 1 && boardState[r-1][c+1] === EMPTY) openEnds++;
                                if (r+count < ROWS && c-count >= 0 && boardState[r+count][c-count] === EMPTY) openEnds++;
                                
                                score += openEnds * count;
                            }
                        }
                    }
                }
            }
            
            return score;
        }
        
        // Set difficulty
        function setDifficulty(difficulty) {
            aiDifficulty = difficulty;
            
            // Update button styling
            difficultyButtons.forEach(button => {
                button.classList.remove('btn-primary', 'btn-danger');
                button.classList.add('btn-outline-primary', 'btn-outline-danger');
            });
            
            const activeButton = document.querySelector(`.difficulty-btn[data-difficulty="${difficulty}"]`);
            if (difficulty === 'easy' || difficulty === 'medium') {
                activeButton.classList.remove('btn-outline-primary');
                activeButton.classList.add('btn-primary');
            } else {
                activeButton.classList.remove('btn-outline-danger');
                activeButton.classList.add('btn-danger');
            }
            
            // Restart the game
            initGame();
        }
        
        // Find lowest empty row in the column for a clone board
        function findLowestEmptyRowInBoard(boardState, col) {
            for (let row = ROWS - 1; row >= 0; row--) {
                if (boardState[row][col] === EMPTY) {
                    return row;
                }
            }
            return -1; // Column is full
        }
        
        // Clone the board
        function cloneBoard(boardState) {
            return boardState.map(row => [...row]);
        }
        
        // Event Listeners
        columnButtons.forEach(button => {
            button.addEventListener('click', function() {
                if (currentPlayer !== PLAYER || !gameActive || aiIsThinking) return;
                const col = parseInt(this.dataset.col);
                makeMove(col);
            });
        });
        
        difficultyButtons.forEach(button => {
            button.addEventListener('click', function() {
                if (aiIsThinking) return;
                setDifficulty(this.dataset.difficulty);
            });
        });
        
        newGameButton.addEventListener('click', function() {
            if (aiIsThinking) return;
            initGame();
        });
        
        undoMoveButton.addEventListener('click', function() {
            if (aiIsThinking) return;
            undoMove();
        });
        
        // Initialize the game on load
        initGame();
    });
</script>
{% endblock %}